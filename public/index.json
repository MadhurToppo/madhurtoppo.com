[{"content":"What You\u0026rsquo;ll Find Here Hello and welcome! I\u0026rsquo;m excited to share my thoughts and experiences in software engineering, cloud-native development, and technology insights.\nIn this blog, I\u0026rsquo;ll be covering:\nSoftware Engineering Best Practices: Lessons learned from building scalable enterprise systems Cloud-Native Development: Microservices, containerization, and modern deployment strategies AI Integration: Working with Spring AI, RAG systems, and LLM implementations Technology Tutorials: Practical guides and how-tos Industry Insights: Thoughts on the evolving tech landscape Stay tuned for more content, and feel free to reach out if you have any questions or topics you\u0026rsquo;d like me to cover!\n","permalink":"https://madhurtoppo.com/posts/welcome/","summary":"\u003ch1 id=\"what-youll-find-here\"\u003eWhat You\u0026rsquo;ll Find Here\u003c/h1\u003e\n\u003cp\u003eHello and welcome! I\u0026rsquo;m excited to share my thoughts and experiences in software engineering, cloud-native development, and technology insights.\u003c/p\u003e\n\u003cp\u003eIn this blog, I\u0026rsquo;ll be covering:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSoftware Engineering Best Practices\u003c/strong\u003e: Lessons learned from building scalable enterprise systems\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCloud-Native Development\u003c/strong\u003e: Microservices, containerization, and modern deployment strategies\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAI Integration\u003c/strong\u003e: Working with Spring AI, RAG systems, and LLM implementations\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTechnology Tutorials\u003c/strong\u003e: Practical guides and how-tos\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIndustry Insights\u003c/strong\u003e: Thoughts on the evolving tech landscape\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eStay tuned for more content, and feel free to reach out if you have any questions or topics you\u0026rsquo;d like me to cover!\u003c/p\u003e","title":"Welcome to My Blog"},{"content":"A Deep Dive into the Java Virtual Machine (JVM): From Source Code toExecution The Java Virtual Machine (JVM) is at the heart of the Java ecosystem. It’s an abstract computing machine that enables Java applications to run anywhere—without needing platform-specific recompilation. But how does Java code actually go from .java files to running processes? Let’s break down the full lifecycle.\nSource Code → Bytecode: Every Java program begins as source code written in .java files. These files are compiled by the Java Compiler (javac) into bytecode, stored in .class files. Source Code Example: public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, JVM!\u0026#34;); } } Compilation Command:\njavac HelloWorld.java Output: HelloWorld.class containing platform-independent bytecode This bytecode is the intermediate representation of the program — not directly executable by the OS, but readable by the JVM.\nJVM Architecture Overview: The JVM has three main subsystems that handle execution:\nClass Loader Subsystem Runtime Data Areas Execution Engine JVM Class Loader Subsystem: The Class Loader is responsible for dynamically loading Java classes into memory during runtime. It works in three main steps:\nLoading: Reads .class files and brings them into the JVM. Linking: Verifies bytecode for security and correctness, prepares memory for class variables, and resolves symbolic references. Initialization: Executes static initializers (static { } blocks) and assigns static variable values. The JVM uses a delegation hierarchy:\nBootstrap Class Loader – Loads core Java classes (java.lang.*, java.util.*) Extension Class Loader – Loads classes from the extension directories Application Class Loader – Loads classes from the user’s classpath JVM Runtime Data Areas: Once classes are loaded, the JVM allocates memory in several runtime areas:\nMethod Area: Stores class structures, method data, and runtime constant pool. Heap: Allocates memory for objects (managed by Garbage Collector). Java Stack: Holds local variables and partial results for each thread. PC Register: Keeps track of the current instruction being executed. Native Method Stack: Supports native (non-Java) code execution through JNI.\nJVM Execution Engine: The Execution Engine is where bytecode becomes actual machine instructions. It has three major components:\nInterpreter: Reads and executes bytecode line by line. JIT (Just-In-Time) Compiler: Converts frequently executed bytecode (“hot code”) into native machine code to boost performance. Garbage Collector (GC): Automatically manages memory, freeing up unused objects from the heap. Together, the Execution Engine and JIT compiler make the JVM fast and adaptive, optimizing execution during runtime. The Complete Flow:\nSource Code (.java) ↓ Compiler (javac) ↓ Bytecode (.class) ↓ Class Loader Subsystem ↓ Runtime Data Areas ↓ Execution Engine (Interpreter + JIT) ↓ Native Machine Code → Execution Conclusion: The JVM is far more than a runtime—it’s a sophisticated platform that abstracts hardware details, manages memory automatically, and optimizes performance on the fly. By transforming source code into bytecode and executing it efficiently through the class loader and execution engine, the JVM remains one of the most powerful virtualized environments in modern computing. ","permalink":"https://madhurtoppo.com/posts/java/jvm-deep-dive/","summary":"\u003ch2 id=\"a-deep-dive-into-the-java-virtual-machine-jvm-from-source-code-toexecution\"\u003eA Deep Dive into the Java Virtual Machine (JVM): From Source Code toExecution\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"jvm-deep-dive.png\" loading=\"lazy\" src=\"/jvm-deep-dive.png\"\u003e\nThe Java Virtual Machine (JVM) is at the heart of the Java ecosystem.\nIt’s an abstract computing machine that enables Java applications to run\nanywhere—without needing platform-specific recompilation. But how does Java code\nactually go from .java files to running processes? Let’s break down the full\nlifecycle.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eSource Code → Bytecode:\u003c/strong\u003e Every Java program begins as source code written\nin .java files. These files are compiled by the Java Compiler (javac) into\nbytecode, stored in .class files. Source Code Example:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eHelloWorld\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e(String\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e args) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       System.\u003cspan style=\"color:#a6e22e\"\u003eout\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Hello, JVM!\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eCompilation Command:\u003c/p\u003e","title":"JVM Deep Dive"}]