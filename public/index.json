[{"content":"What You\u0026rsquo;ll Find Here Hello and welcome! I\u0026rsquo;m excited to share my thoughts and experiences in software engineering, cloud-native development, and technology insights.\nIn this blog, I\u0026rsquo;ll be covering:\nSoftware Engineering Best Practices: Lessons learned from building scalable enterprise systems Cloud-Native Development: Microservices, containerization, and modern deployment strategies AI Integration: Working with Spring AI, RAG systems, and LLM implementations Technology Tutorials: Practical guides and how-tos Industry Insights: Thoughts on the evolving tech landscape Stay tuned for more content, and feel free to reach out if you have any questions or topics you\u0026rsquo;d like me to cover!\n","permalink":"https://madhurtoppo.com/posts/welcome/","summary":"\u003ch1 id=\"what-youll-find-here\"\u003eWhat You\u0026rsquo;ll Find Here\u003c/h1\u003e\n\u003cp\u003eHello and welcome! I\u0026rsquo;m excited to share my thoughts and experiences in software engineering, cloud-native development, and technology insights.\u003c/p\u003e\n\u003cp\u003eIn this blog, I\u0026rsquo;ll be covering:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSoftware Engineering Best Practices\u003c/strong\u003e: Lessons learned from building scalable enterprise systems\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCloud-Native Development\u003c/strong\u003e: Microservices, containerization, and modern deployment strategies\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAI Integration\u003c/strong\u003e: Working with Spring AI, RAG systems, and LLM implementations\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTechnology Tutorials\u003c/strong\u003e: Practical guides and how-tos\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIndustry Insights\u003c/strong\u003e: Thoughts on the evolving tech landscape\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eStay tuned for more content, and feel free to reach out if you have any questions or topics you\u0026rsquo;d like me to cover!\u003c/p\u003e","title":"Welcome to My Blog"},{"content":"Observability and Monitoring in Modern Spring Boot Applications Modern distributed systems are complex â€” dozens of services, asynchronous communication, and dynamic scaling make understanding whatâ€™s happening inside the system harder than ever. Thatâ€™s whereÂ ObservabilityÂ andÂ Monitoring come in.\nWhileÂ MonitoringÂ tells usÂ thatÂ something is wrong,Â ObservabilityÂ helps us understandÂ whyÂ itâ€™s wrong. In a typical Spring Boot microservice setup, observability involves 3 core pillars:\nğŸ§­ 1. Metrics â€” Quantifying System Health Metrics give a numerical insights about system behavior â€” CPU usage, request latency, error rates, etc.\nIn a Spring Boot ecosystem, we can easily enable metrics usingÂ Micrometer:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-registry-prometheus\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Once added, the application automatically exposes metrics at the /actuator/prometheusÂ endpoint.\nPrometheusÂ regularly scrapes these metrics and stores them in its time-series database. From there,Â GrafanaÂ connects to Prometheus to visualize dashboards and create alerts.\nâœ…Â Metrics Pipeline Summary:\nSpring Boot (Micrometer) â†’ /actuator/prometheus â†’ Prometheus â†’ Grafana This pipeline gives a real-time visibility into the application performance â€” we can chart request rates, error percentages, JVM memory, and more.\nğŸ” 2. Traces â€” Following a Request Across Services Metrics are great, but they donâ€™t tell the story ofÂ oneÂ specific request. Thatâ€™s whereÂ Distributed TracingÂ comes in.\nWithÂ OpenTelemetry, the Spring Boot services can be automatically instrumented by adding theÂ OpenTelemetry Java AgentÂ or SDK.\nThis agent captures:\nHTTP client \u0026amp; server spans Database queries Messaging (Kafka, RabbitMQ) interactions Traces are then exported inÂ OTLP (OpenTelemetry Protocol)Â format to the OpenTelemetry Collector, which forwards them toÂ Tempo, a distributed tracing backend.\nGrafanaÂ integrates with Tempo, allowing to visualize traces and understand latency across microservices.\nâœ…Â Tracing Pipeline Summary:\nSpring Boot (OpenTelemetry) â†’ OTLP â†’ OpenTelemetry Collector â†’ Tempo â†’ Grafana This pipeline helps answerÂ whyÂ a request was slow â€” bottlenecks can be pinpointed down to individual database calls.\nğŸ§¾ 3. Logs â€” Contextual Insights for Debugging Logs capture the raw narrative of whatâ€™s happening inside the application. When properly structured and correlated with traces, they become a powerful debugging tool.\nUsing theÂ Loki Logback Appender, the Spring Boot apps can send logs directly toÂ Loki:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.loki4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;loki-logback-appender\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Each log entry is labeled (e.g.,Â service=order-service,Â level=INFO) for fast querying in Grafana. When integrated with OpenTelemetry, the logs also include traceIdÂ andÂ spanIdÂ in the MDC â€” allowing them to correlate logs with traces.\nâœ…Â Logs Pipeline Summary:\nSpring Boot (Loki Appender) â†’ Loki â†’ Grafana Now, a single Grafana dashboard can be used to:\nVisualize metrics trends Explore distributed traces Drill down into correlated logs ğŸ¯ Bringing It All Together When these three pipelines work in harmony â€”Â Metrics,Â Traces, and LogsÂ â€” a full-stackÂ Monitoring and Observability can be achieved.\nMetrics â†’ Whatâ€™s happening? Traces â†’ Where is it happening? Logs â†’ Why is it happening? Together, they form aÂ feedback loopÂ that enables proactive monitoring, faster incident resolution, and deeper insight into the systemâ€™s behavior.\nğŸš€ Final Takeaway Monitoring and Observability arenâ€™t tools â€” they are a mindset. They are about building systems that tell their own stories. With Spring Boot, Micrometer, OpenTelemetry, Prometheus, Loki, Tempo, and Grafana, we have all the pieces to make that story visible.\n","permalink":"https://madhurtoppo.com/posts/cloud-native/observability-and-monitoring/","summary":"\u003ch1 id=\"observability-and-monitoring-in-modern-spring-boot-applications\"\u003eObservability and Monitoring in Modern Spring Boot Applications\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"observability.png\" loading=\"lazy\" src=\"observability.png\"\u003e\u003c/p\u003e\n\u003cp\u003eModern distributed systems are complex â€” dozens of services, asynchronous\ncommunication, and dynamic scaling make understanding whatâ€™s happening inside\nthe system harder than ever. Thatâ€™s whereÂ \u003cstrong\u003eObservability\u003c/strong\u003eÂ andÂ \u003cstrong\u003eMonitoring\u003c/strong\u003e\ncome in.\u003c/p\u003e\n\u003cp\u003eWhileÂ \u003cstrong\u003eMonitoring\u003c/strong\u003eÂ tells usÂ \u003cem\u003ethat\u003c/em\u003eÂ something is wrong,Â \u003cstrong\u003eObservability\u003c/strong\u003eÂ helps\nus understandÂ \u003cem\u003ewhy\u003c/em\u003eÂ itâ€™s wrong. In a typical Spring Boot microservice setup,\nobservability involves 3 core pillars:\u003c/p\u003e\n\u003ch2 id=\"-1-metrics--quantifying-system-health\"\u003eğŸ§­ 1. Metrics â€” Quantifying System Health\u003c/h2\u003e\n\u003cp\u003eMetrics give a numerical insights about system behavior â€” CPU usage, request latency, error rates, etc.\u003c/p\u003e","title":"Observability and Monitoring"},{"content":"A Deep Dive into the Java Virtual Machine (JVM): From Source Code toExecution The Java Virtual Machine (JVM) is at the heart of the Java ecosystem. Itâ€™s an abstract computing machine that enables Java applications to run anywhereâ€”without needing platform-specific recompilation. But how does Java code actually go from .java files to running processes? Letâ€™s break down the full lifecycle.\nSource Code â†’ Bytecode: Every Java program begins as source code written in .java files. These files are compiled by the Java Compiler (javac) into bytecode, stored in .class files. Source Code Example: public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, JVM!\u0026#34;); } } Compilation Command:\njavac HelloWorld.java Output: HelloWorld.class containing platform-independent bytecode This bytecode is the intermediate representation of the program â€” not directly executable by the OS, but readable by the JVM.\nJVM Architecture Overview: The JVM has three main subsystems that handle execution:\nClass Loader Subsystem Runtime Data Areas Execution Engine JVM Class Loader Subsystem: The Class Loader is responsible for dynamically loading Java classes into memory during runtime. It works in three main steps:\nLoading: Reads .class files and brings them into the JVM. Linking: Verifies bytecode for security and correctness, prepares memory for class variables, and resolves symbolic references. Initialization: Executes static initializers (static { } blocks) and assigns static variable values. The JVM uses a delegation hierarchy:\nBootstrap Class Loader â€“ Loads core Java classes (java.lang.*, java.util.*) Extension Class Loader â€“ Loads classes from the extension directories Application Class Loader â€“ Loads classes from the userâ€™s classpath JVM Runtime Data Areas: Once classes are loaded, the JVM allocates memory in several runtime areas:\nMethod Area: Stores class structures, method data, and runtime constant pool. Heap: Allocates memory for objects (managed by Garbage Collector). Java Stack: Holds local variables and partial results for each thread. PC Register: Keeps track of the current instruction being executed. Native Method Stack: Supports native (non-Java) code execution through JNI.\nJVM Execution Engine: The Execution Engine is where bytecode becomes actual machine instructions. It has three major components:\nInterpreter: Reads and executes bytecode line by line. JIT (Just-In-Time) Compiler: Converts frequently executed bytecode (â€œhot codeâ€) into native machine code to boost performance. Garbage Collector (GC): Automatically manages memory, freeing up unused objects from the heap. Together, the Execution Engine and JIT compiler make the JVM fast and adaptive, optimizing execution during runtime. The Complete Flow:\nSource Code (.java) â†“ Compiler (javac) â†“ Bytecode (.class) â†“ Class Loader Subsystem â†“ Runtime Data Areas â†“ Execution Engine (Interpreter + JIT) â†“ Native Machine Code â†’ Execution Conclusion: The JVM is far more than a runtimeâ€”itâ€™s a sophisticated platform that abstracts hardware details, manages memory automatically, and optimizes performance on the fly. By transforming source code into bytecode and executing it efficiently through the class loader and execution engine, the JVM remains one of the most powerful virtualized environments in modern computing. ","permalink":"https://madhurtoppo.com/posts/java/jvm-deep-dive/","summary":"\u003ch2 id=\"a-deep-dive-into-the-java-virtual-machine-jvm-from-source-code-toexecution\"\u003eA Deep Dive into the Java Virtual Machine (JVM): From Source Code toExecution\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"jvm-deep-dive.png\" loading=\"lazy\" src=\"/jvm-deep-dive.png\"\u003e\nThe Java Virtual Machine (JVM) is at the heart of the Java ecosystem.\nItâ€™s an abstract computing machine that enables Java applications to run\nanywhereâ€”without needing platform-specific recompilation. But how does Java code\nactually go from .java files to running processes? Letâ€™s break down the full\nlifecycle.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eSource Code â†’ Bytecode:\u003c/strong\u003e Every Java program begins as source code written\nin .java files. These files are compiled by the Java Compiler (javac) into\nbytecode, stored in .class files. Source Code Example:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eHelloWorld\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e(String\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e args) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       System.\u003cspan style=\"color:#a6e22e\"\u003eout\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Hello, JVM!\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eCompilation Command:\u003c/p\u003e","title":"JVM Deep Dive"}]