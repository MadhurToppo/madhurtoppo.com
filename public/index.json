[{"content":"What You\u0026rsquo;ll Find Here Hello and welcome! I\u0026rsquo;m excited to share my thoughts and experiences in software engineering, cloud-native development, and technology insights.\nIn this blog, I\u0026rsquo;ll be covering:\nSoftware Engineering Best Practices: Lessons learned from building scalable enterprise systems Cloud-Native Development: Microservices, containerization, and modern deployment strategies AI Integration: Working with Spring AI, RAG systems, and LLM implementations Technology Tutorials: Practical guides and how-tos Industry Insights: Thoughts on the evolving tech landscape Stay tuned for more content, and feel free to reach out if you have any questions or topics you\u0026rsquo;d like me to cover!\n","permalink":"https://madhurtoppo.com/posts/welcome/","summary":"\u003ch1 id=\"what-youll-find-here\"\u003eWhat You\u0026rsquo;ll Find Here\u003c/h1\u003e\n\u003cp\u003eHello and welcome! I\u0026rsquo;m excited to share my thoughts and experiences in software engineering, cloud-native development, and technology insights.\u003c/p\u003e\n\u003cp\u003eIn this blog, I\u0026rsquo;ll be covering:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSoftware Engineering Best Practices\u003c/strong\u003e: Lessons learned from building scalable enterprise systems\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCloud-Native Development\u003c/strong\u003e: Microservices, containerization, and modern deployment strategies\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAI Integration\u003c/strong\u003e: Working with Spring AI, RAG systems, and LLM implementations\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTechnology Tutorials\u003c/strong\u003e: Practical guides and how-tos\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIndustry Insights\u003c/strong\u003e: Thoughts on the evolving tech landscape\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eStay tuned for more content, and feel free to reach out if you have any questions or topics you\u0026rsquo;d like me to cover!\u003c/p\u003e","title":"Welcome to My Blog"},{"content":"Observability and Monitoring in Modern Spring Boot Applications Modern distributed systems are complex — dozens of services, asynchronous communication, and dynamic scaling make understanding what’s happening inside the system harder than ever. That’s where Observability and Monitoring come in.\nWhile Monitoring tells us that something is wrong, Observability helps us understand why it’s wrong. In a typical Spring Boot microservice setup, observability involves 3 core pillars:\n🧭 1. Metrics — Quantifying System Health Metrics give a numerical insights about system behavior — CPU usage, request latency, error rates, etc.\nIn a Spring Boot ecosystem, we can easily enable metrics using Micrometer:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-registry-prometheus\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Once added, the application automatically exposes metrics at the /actuator/prometheus endpoint.\nPrometheus regularly scrapes these metrics and stores them in its time-series database. From there, Grafana connects to Prometheus to visualize dashboards and create alerts.\n✅ Metrics Pipeline Summary:\nSpring Boot (Micrometer) → /actuator/prometheus → Prometheus → Grafana This pipeline gives a real-time visibility into the application performance — we can chart request rates, error percentages, JVM memory, and more.\n🔍 2. Traces — Following a Request Across Services Metrics are great, but they don’t tell the story of one specific request. That’s where Distributed Tracing comes in.\nWith OpenTelemetry, the Spring Boot services can be automatically instrumented by adding the OpenTelemetry Java Agent or SDK.\nThis agent captures:\nHTTP client \u0026amp; server spans Database queries Messaging (Kafka, RabbitMQ) interactions Traces are then exported in OTLP (OpenTelemetry Protocol) format to the OpenTelemetry Collector, which forwards them to Tempo, a distributed tracing backend.\nGrafana integrates with Tempo, allowing to visualize traces and understand latency across microservices.\n✅ Tracing Pipeline Summary:\nSpring Boot (OpenTelemetry) → OTLP → OpenTelemetry Collector → Tempo → Grafana This pipeline helps answer why a request was slow — bottlenecks can be pinpointed down to individual database calls.\n🧾 3. Logs — Contextual Insights for Debugging Logs capture the raw narrative of what’s happening inside the application. When properly structured and correlated with traces, they become a powerful debugging tool.\nUsing the Loki Logback Appender, the Spring Boot apps can send logs directly to Loki:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.loki4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;loki-logback-appender\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Each log entry is labeled (e.g., service=order-service, level=INFO) for fast querying in Grafana. When integrated with OpenTelemetry, the logs also include traceId and spanId in the MDC — allowing them to correlate logs with traces.\n✅ Logs Pipeline Summary:\nSpring Boot (Loki Appender) → Loki → Grafana Now, a single Grafana dashboard can be used to:\nVisualize metrics trends Explore distributed traces Drill down into correlated logs 🎯 Bringing It All Together When these three pipelines work in harmony — Metrics, Traces, and Logs — a full-stack Monitoring and Observability can be achieved.\nMetrics → What’s happening? Traces → Where is it happening? Logs → Why is it happening? Together, they form a feedback loop that enables proactive monitoring, faster incident resolution, and deeper insight into the system’s behavior.\n🚀 Final Takeaway Monitoring and Observability aren’t tools — they are a mindset. They are about building systems that tell their own stories. With Spring Boot, Micrometer, OpenTelemetry, Prometheus, Loki, Tempo, and Grafana, we have all the pieces to make that story visible.\n","permalink":"https://madhurtoppo.com/posts/cloud-native/observability-and-monitoring/","summary":"\u003ch1 id=\"observability-and-monitoring-in-modern-spring-boot-applications\"\u003eObservability and Monitoring in Modern Spring Boot Applications\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"observability.png\" loading=\"lazy\" src=\"observability.png\"\u003e\u003c/p\u003e\n\u003cp\u003eModern distributed systems are complex — dozens of services, asynchronous\ncommunication, and dynamic scaling make understanding what’s happening inside\nthe system harder than ever. That’s where \u003cstrong\u003eObservability\u003c/strong\u003e and \u003cstrong\u003eMonitoring\u003c/strong\u003e\ncome in.\u003c/p\u003e\n\u003cp\u003eWhile \u003cstrong\u003eMonitoring\u003c/strong\u003e tells us \u003cem\u003ethat\u003c/em\u003e something is wrong, \u003cstrong\u003eObservability\u003c/strong\u003e helps\nus understand \u003cem\u003ewhy\u003c/em\u003e it’s wrong. In a typical Spring Boot microservice setup,\nobservability involves 3 core pillars:\u003c/p\u003e\n\u003ch2 id=\"-1-metrics--quantifying-system-health\"\u003e🧭 1. Metrics — Quantifying System Health\u003c/h2\u003e\n\u003cp\u003eMetrics give a numerical insights about system behavior — CPU usage, request latency, error rates, etc.\u003c/p\u003e","title":"Observability and Monitoring"},{"content":"A Deep Dive into the Java Virtual Machine (JVM): From Source Code toExecution The Java Virtual Machine (JVM) is at the heart of the Java ecosystem. It’s an abstract computing machine that enables Java applications to run anywhere—without needing platform-specific recompilation. But how does Java code actually go from .java files to running processes? Let’s break down the full lifecycle.\nSource Code → Bytecode: Every Java program begins as source code written in .java files. These files are compiled by the Java Compiler (javac) into bytecode, stored in .class files. Source Code Example: public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, JVM!\u0026#34;); } } Compilation Command:\njavac HelloWorld.java Output: HelloWorld.class containing platform-independent bytecode This bytecode is the intermediate representation of the program — not directly executable by the OS, but readable by the JVM.\nJVM Architecture Overview: The JVM has three main subsystems that handle execution:\nClass Loader Subsystem Runtime Data Areas Execution Engine JVM Class Loader Subsystem: The Class Loader is responsible for dynamically loading Java classes into memory during runtime. It works in three main steps:\nLoading: Reads .class files and brings them into the JVM. Linking: Verifies bytecode for security and correctness, prepares memory for class variables, and resolves symbolic references. Initialization: Executes static initializers (static { } blocks) and assigns static variable values. The JVM uses a delegation hierarchy:\nBootstrap Class Loader – Loads core Java classes (java.lang.*, java.util.*) Extension Class Loader – Loads classes from the extension directories Application Class Loader – Loads classes from the user’s classpath JVM Runtime Data Areas: Once classes are loaded, the JVM allocates memory in several runtime areas:\nMethod Area: Stores class structures, method data, and runtime constant pool. Heap: Allocates memory for objects (managed by Garbage Collector). Java Stack: Holds local variables and partial results for each thread. PC Register: Keeps track of the current instruction being executed. Native Method Stack: Supports native (non-Java) code execution through JNI.\nJVM Execution Engine: The Execution Engine is where bytecode becomes actual machine instructions. It has three major components:\nInterpreter: Reads and executes bytecode line by line. JIT (Just-In-Time) Compiler: Converts frequently executed bytecode (“hot code”) into native machine code to boost performance. Garbage Collector (GC): Automatically manages memory, freeing up unused objects from the heap. Together, the Execution Engine and JIT compiler make the JVM fast and adaptive, optimizing execution during runtime. The Complete Flow:\nSource Code (.java) ↓ Compiler (javac) ↓ Bytecode (.class) ↓ Class Loader Subsystem ↓ Runtime Data Areas ↓ Execution Engine (Interpreter + JIT) ↓ Native Machine Code → Execution Conclusion: The JVM is far more than a runtime—it’s a sophisticated platform that abstracts hardware details, manages memory automatically, and optimizes performance on the fly. By transforming source code into bytecode and executing it efficiently through the class loader and execution engine, the JVM remains one of the most powerful virtualized environments in modern computing. ","permalink":"https://madhurtoppo.com/posts/java/jvm-deep-dive/","summary":"\u003ch2 id=\"a-deep-dive-into-the-java-virtual-machine-jvm-from-source-code-toexecution\"\u003eA Deep Dive into the Java Virtual Machine (JVM): From Source Code toExecution\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"jvm-deep-dive.png\" loading=\"lazy\" src=\"/jvm-deep-dive.png\"\u003e\nThe Java Virtual Machine (JVM) is at the heart of the Java ecosystem.\nIt’s an abstract computing machine that enables Java applications to run\nanywhere—without needing platform-specific recompilation. But how does Java code\nactually go from .java files to running processes? Let’s break down the full\nlifecycle.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eSource Code → Bytecode:\u003c/strong\u003e Every Java program begins as source code written\nin .java files. These files are compiled by the Java Compiler (javac) into\nbytecode, stored in .class files. Source Code Example:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eHelloWorld\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e(String\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e args) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       System.\u003cspan style=\"color:#a6e22e\"\u003eout\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Hello, JVM!\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eCompilation Command:\u003c/p\u003e","title":"JVM Deep Dive"}]