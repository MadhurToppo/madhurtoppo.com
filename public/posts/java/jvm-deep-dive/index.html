<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>JVM Deep Dive | Madhur Toppo</title>
<meta name="keywords" content="">
<meta name="description" content="A Deep Dive into the Java Virtual Machine (JVM): From Source Code toExecution

The Java Virtual Machine (JVM) is at the heart of the Java ecosystem.
It’s an abstract computing machine that enables Java applications to run
anywhere—without needing platform-specific recompilation. But how does Java code
actually go from .java files to running processes? Let’s break down the full
lifecycle.

Source Code → Bytecode: Every Java program begins as source code written
in .java files. These files are compiled by the Java Compiler (javac) into
bytecode, stored in .class files. Source Code Example:

public class HelloWorld {
   public static void main(String[] args) {
       System.out.println(&#34;Hello, JVM!&#34;);
   }
}
Compilation Command:">
<meta name="author" content="">
<link rel="canonical" href="https://madhurtoppo.com/posts/java/jvm-deep-dive/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css" integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn&#43;yY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://madhurtoppo.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://madhurtoppo.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://madhurtoppo.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://madhurtoppo.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://madhurtoppo.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://madhurtoppo.com/posts/java/jvm-deep-dive/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://madhurtoppo.com/posts/java/jvm-deep-dive/">
  <meta property="og:site_name" content="Madhur Toppo">
  <meta property="og:title" content="JVM Deep Dive">
  <meta property="og:description" content="A Deep Dive into the Java Virtual Machine (JVM): From Source Code toExecution The Java Virtual Machine (JVM) is at the heart of the Java ecosystem. It’s an abstract computing machine that enables Java applications to run anywhere—without needing platform-specific recompilation. But how does Java code actually go from .java files to running processes? Let’s break down the full lifecycle.
Source Code → Bytecode: Every Java program begins as source code written in .java files. These files are compiled by the Java Compiler (javac) into bytecode, stored in .class files. Source Code Example: public class HelloWorld { public static void main(String[] args) { System.out.println(&#34;Hello, JVM!&#34;); } } Compilation Command:">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-13T11:32:09+02:00">
    <meta property="article:modified_time" content="2025-10-13T11:32:09+02:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM Deep Dive">
<meta name="twitter:description" content="A Deep Dive into the Java Virtual Machine (JVM): From Source Code toExecution

The Java Virtual Machine (JVM) is at the heart of the Java ecosystem.
It’s an abstract computing machine that enables Java applications to run
anywhere—without needing platform-specific recompilation. But how does Java code
actually go from .java files to running processes? Let’s break down the full
lifecycle.

Source Code → Bytecode: Every Java program begins as source code written
in .java files. These files are compiled by the Java Compiler (javac) into
bytecode, stored in .class files. Source Code Example:

public class HelloWorld {
   public static void main(String[] args) {
       System.out.println(&#34;Hello, JVM!&#34;);
   }
}
Compilation Command:">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blog Posts",
      "item": "https://madhurtoppo.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "JVM Deep Dive",
      "item": "https://madhurtoppo.com/posts/java/jvm-deep-dive/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JVM Deep Dive",
  "name": "JVM Deep Dive",
  "description": "A Deep Dive into the Java Virtual Machine (JVM): From Source Code toExecution The Java Virtual Machine (JVM) is at the heart of the Java ecosystem. It’s an abstract computing machine that enables Java applications to run anywhere—without needing platform-specific recompilation. But how does Java code actually go from .java files to running processes? Let’s break down the full lifecycle.\nSource Code → Bytecode: Every Java program begins as source code written in .java files. These files are compiled by the Java Compiler (javac) into bytecode, stored in .class files. Source Code Example: public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, JVM!\u0026#34;); } } Compilation Command:\n",
  "keywords": [
    
  ],
  "articleBody": "A Deep Dive into the Java Virtual Machine (JVM): From Source Code toExecution The Java Virtual Machine (JVM) is at the heart of the Java ecosystem. It’s an abstract computing machine that enables Java applications to run anywhere—without needing platform-specific recompilation. But how does Java code actually go from .java files to running processes? Let’s break down the full lifecycle.\nSource Code → Bytecode: Every Java program begins as source code written in .java files. These files are compiled by the Java Compiler (javac) into bytecode, stored in .class files. Source Code Example: public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello, JVM!\"); } } Compilation Command:\njavac HelloWorld.java Output: HelloWorld.class containing platform-independent bytecode This bytecode is the intermediate representation of the program — not directly executable by the OS, but readable by the JVM.\nJVM Architecture Overview: The JVM has three main subsystems that handle execution:\nClass Loader Subsystem Runtime Data Areas Execution Engine JVM Class Loader Subsystem The Class Loader is responsible for dynamically loading Java classes into memory during runtime. It works in three main steps:\nLoading: Reads .class files and brings them into the JVM. Linking: Verifies bytecode for security and correctness, prepares memory for class variables, and resolves symbolic references. Initialization: Executes static initializers (static { } blocks) and assigns static variable values. The JVM uses a delegation hierarchy:\nBootstrap Class Loader – Loads core Java classes (java.lang.*, java.util.*) Extension Class Loader – Loads classes from the extension directories Application Class Loader – Loads classes from the user’s classpath JVM Runtime Data Areas Once classes are loaded, the JVM allocates memory in several runtime areas:\nMethod Area: Stores class structures, method data, and runtime constant pool. Heap: Allocates memory for objects (managed by Garbage Collector). Java Stack: Holds local variables and partial results for each thread. PC Register: Keeps track of the current instruction being executed. Native Method Stack: Supports native (non-Java) code execution through JNI.\nJVM Execution Engine The Execution Engine is where bytecode becomes actual machine instructions. It has three major components:\nInterpreter: Reads and executes bytecode line by line. JIT (Just-In-Time) Compiler: Converts frequently executed bytecode (“hot code”) into native machine code to boost performance. Garbage Collector (GC): Automatically manages memory, freeing up unused objects from the heap. Together, the Execution Engine and JIT compiler make the JVM fast and adaptive, optimizing execution during runtime. The Complete Flow\nSource Code (.java) ↓ Compiler (javac) ↓ Bytecode (.class) ↓ Class Loader Subsystem ↓ Runtime Data Areas ↓ Execution Engine (Interpreter + JIT) ↓ Native Machine Code → Execution Conclusion The JVM is far more than a runtime—it’s a sophisticated platform that abstracts hardware details, manages memory automatically, and optimizes performance on the fly. By transforming source code into bytecode and executing it efficiently through the class loader and execution engine, the JVM remains one of the most powerful virtualized environments in modern computing. ",
  "wordCount" : "482",
  "inLanguage": "en",
  "datePublished": "2025-10-13T11:32:09+02:00",
  "dateModified": "2025-10-13T11:32:09+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://madhurtoppo.com/posts/java/jvm-deep-dive/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Madhur Toppo",
    "logo": {
      "@type": "ImageObject",
      "url": "https://madhurtoppo.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://madhurtoppo.com/" accesskey="h" title="Madhur Toppo (Alt + H)">Madhur Toppo</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://madhurtoppo.com/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://madhurtoppo.com/posts" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://madhurtoppo.com/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      JVM Deep Dive
    </h1>
    <div class="post-meta"><span title='2025-10-13 11:32:09 +0200 CEST'>October 13, 2025</span>

</div>
  </header> 
  <div class="post-content"><h2 id="a-deep-dive-into-the-java-virtual-machine-jvm-from-source-code-toexecution">A Deep Dive into the Java Virtual Machine (JVM): From Source Code toExecution<a hidden class="anchor" aria-hidden="true" href="#a-deep-dive-into-the-java-virtual-machine-jvm-from-source-code-toexecution">#</a></h2>
<p><img alt="jvm-deep-dive.png" loading="lazy" src="jvm-deep-dive.png">
The Java Virtual Machine (JVM) is at the heart of the Java ecosystem.
It’s an abstract computing machine that enables Java applications to run
anywhere—without needing platform-specific recompilation. But how does Java code
actually go from .java files to running processes? Let’s break down the full
lifecycle.</p>
<ol>
<li><strong>Source Code → Bytecode:</strong> Every Java program begins as source code written
in .java files. These files are compiled by the Java Compiler (javac) into
bytecode, stored in .class files. Source Code Example:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HelloWorld</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>       System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Hello, JVM!&#34;</span>);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Compilation Command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>javac HelloWorld.<span style="color:#a6e22e">java</span>
</span></span></code></pre></div><p>Output: <code>HelloWorld.class</code> containing platform-independent bytecode This
bytecode is the intermediate representation of the program — not directly
executable by the OS, but readable by the JVM.</p>
<ol start="2">
<li>
<p><strong>JVM Architecture Overview:</strong> The JVM has three main subsystems that handle
execution:</p>
<ol>
<li>Class Loader Subsystem</li>
<li>Runtime Data Areas</li>
<li>Execution Engine</li>
</ol>
</li>
<li>
<p><strong>JVM Class Loader Subsystem</strong>
The Class Loader is responsible for dynamically loading Java classes into
memory during runtime. It works in three main steps:</p>
<ol>
<li>Loading: Reads <code>.class</code> files and brings them into the JVM.</li>
<li>Linking: Verifies bytecode for security and correctness, prepares memory for class variables, and resolves symbolic references.</li>
<li>Initialization: Executes static initializers (<code>static { }</code> blocks) and assigns static variable values.</li>
</ol>
<p>The JVM uses a delegation hierarchy:</p>
<ol>
<li>Bootstrap Class Loader – Loads core Java classes (<code>java.lang.*, java.util.*</code>)</li>
<li>Extension Class Loader – Loads classes from the extension directories</li>
<li>Application Class Loader – Loads classes from the user’s classpath</li>
</ol>
</li>
<li>
<p><strong>JVM Runtime Data Areas</strong>
Once classes are loaded, the JVM allocates memory in several runtime areas:</p>
<p>Method Area: Stores class structures, method data, and runtime constant pool.
Heap: Allocates memory for objects (managed by Garbage Collector). Java
Stack: Holds local variables and partial results for each thread. PC
Register: Keeps track of the current instruction being executed. Native
Method Stack: Supports native (non-Java) code execution through JNI.</p>
</li>
<li>
<p><strong>JVM Execution Engine</strong>
The Execution Engine is where bytecode becomes actual machine instructions.
It has three major components:</p>
<ol>
<li>Interpreter: Reads and executes bytecode line by line. JIT (Just-In-Time)</li>
<li>Compiler: Converts frequently executed bytecode (“hot code”) into native
machine code to boost performance.</li>
<li>Garbage Collector (GC): Automatically manages memory, freeing up unused
objects from the heap. Together, the Execution Engine and JIT compiler make the
JVM fast and adaptive, optimizing execution during runtime.</li>
</ol>
</li>
<li>
<p><strong>The Complete Flow</strong></p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scss" data-lang="scss"><span style="display:flex;"><span><span style="color:#f92672">Source</span> <span style="color:#f92672">Code</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">.java</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">↓</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">Compiler</span> <span style="color:#f92672">(</span><span style="color:#f92672">javac</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">↓</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">Bytecode</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">.class</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">↓</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">Class</span> <span style="color:#f92672">Loader</span> <span style="color:#f92672">Subsystem</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">↓</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">Runtime</span> <span style="color:#f92672">Data</span> <span style="color:#f92672">Areas</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">↓</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">Execution</span> <span style="color:#f92672">Engine</span> <span style="color:#f92672">(</span><span style="color:#f92672">Interpreter</span> <span style="color:#f92672">+</span> <span style="color:#f92672">JIT</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">↓</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">Native</span> <span style="color:#f92672">Machine</span> <span style="color:#f92672">Code</span> <span style="color:#960050;background-color:#1e0010">→</span> <span style="color:#f92672">Execution</span>
</span></span></code></pre></div><ol start="7">
<li><strong>Conclusion</strong>
The JVM is far more than a runtime—it’s a sophisticated platform that
abstracts hardware details, manages memory automatically, and optimizes
performance on the fly. By transforming source code into bytecode and
executing it efficiently through the class loader and execution engine, the
JVM remains one of the most powerful virtualized environments in modern
computing.</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://madhurtoppo.com/">Madhur Toppo</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
